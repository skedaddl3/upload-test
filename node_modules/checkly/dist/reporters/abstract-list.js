"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const indent_string_1 = __importDefault(require("indent-string"));
const util_1 = require("./util");
const api_1 = require("../rest/api");
class AbstractListReporter {
    constructor(runLocation, verbose) {
        this._clearString = '';
        this.runLocation = runLocation;
        this.verbose = verbose;
    }
    onBegin(checks, testSessionId) {
        this.testSessionId = testSessionId;
        this.numChecks = checks.length;
        // Sort the check files and checks alphabetically. This makes sure that there's a consistent order between runs.
        // For `checkly trigger`, getSourceFile() is not defined so we use optional chaining.
        const sortedCheckFiles = [...new Set(checks.map(({ check }) => { var _a; return (_a = check.getSourceFile) === null || _a === void 0 ? void 0 : _a.call(check); }))].sort();
        const sortedChecks = checks.sort(({ check: a }, { check: b }) => a.name.localeCompare(b.name));
        this.checkFilesMap = new Map(sortedCheckFiles.map((file) => [file, new Map()]));
        sortedChecks.forEach(({ check, testResultId, checkRunId }) => {
            var _a;
            const fileMap = this.checkFilesMap.get((_a = check.getSourceFile) === null || _a === void 0 ? void 0 : _a.call(check));
            fileMap.set(checkRunId, {
                check,
                titleString: (0, util_1.formatCheckTitle)(util_1.CheckStatus.SCHEDULING, check),
                checkStatus: util_1.CheckStatus.SCHEDULING,
                testResultId,
            });
        });
    }
    onCheckInProgress(check, checkRunId) {
        var _a;
        const checkFile = this.checkFilesMap.get((_a = check.getSourceFile) === null || _a === void 0 ? void 0 : _a.call(check)).get(checkRunId);
        checkFile.titleString = (0, util_1.formatCheckTitle)(util_1.CheckStatus.RUNNING, check);
        checkFile.checkStatus = util_1.CheckStatus.RUNNING;
    }
    onSchedulingDelayExceeded() {
        this._isSchedulingDelayExceeded = true;
    }
    onCheckEnd(checkRunId, checkResult) {
        const checkStatus = this.checkFilesMap.get(checkResult.sourceFile).get(checkRunId);
        checkStatus.result = checkResult;
        const status = checkResult.hasFailures ? util_1.CheckStatus.FAILED : util_1.CheckStatus.SUCCESSFUL;
        checkStatus.titleString = (0, util_1.formatCheckTitle)(status, checkResult, {
            includeSourceFile: false,
        });
    }
    onError(err) {
        (0, util_1.printLn)(chalk_1.default.red('Unable to run checks: ') + err.message);
    }
    // Clear the summary which was printed by _printStatus from stdout
    // TODO: Rather than clearing the whole status bar, we could overwrite the exact lines that changed.
    // This might look a bit smoother and reduce the flickering effects.
    _clearSummary() {
        (0, util_1.printLn)(this._clearString);
    }
    _printSummary(opts = {}) {
        const counts = { numFailed: 0, numPassed: 0, numRunning: 0, scheduling: 0 };
        const status = [];
        if (this.checkFilesMap.size === 1 && this.checkFilesMap.has(undefined)) {
            status.push(chalk_1.default.bold('Summary:'));
        }
        for (const [sourceFile, checkMap] of this.checkFilesMap.entries()) {
            if (sourceFile)
                status.push(sourceFile);
            for (const [_, { titleString, result, checkStatus }] of checkMap.entries()) {
                if (checkStatus === util_1.CheckStatus.SCHEDULING) {
                    counts.scheduling++;
                }
                else if (!result) {
                    counts.numRunning++;
                }
                else if (result.hasFailures) {
                    counts.numFailed++;
                }
                else {
                    counts.numPassed++;
                }
                status.push(sourceFile ? (0, indent_string_1.default)(titleString, 2) : titleString);
            }
        }
        if (!opts.skipCheckCount) {
            status.push('');
            status.push([
                counts.scheduling ? chalk_1.default.bold.blue(`${counts.scheduling} scheduling`) : undefined,
                counts.numRunning ? chalk_1.default.bold.magenta(`${counts.numRunning} running`) : undefined,
                counts.numFailed ? chalk_1.default.bold.red(`${counts.numFailed} failed`) : undefined,
                counts.numPassed ? chalk_1.default.bold.green(`${counts.numPassed} passed`) : undefined,
                `${this.numChecks} total`,
            ].filter(Boolean).join(', '));
            if (this._isSchedulingDelayExceeded && counts.scheduling) {
                status.push('Still waiting to schedule some checks. This may take a minute or two.');
            }
        }
        status.push('');
        const statusString = status.join('\n');
        (0, util_1.printLn)(statusString);
        // Ansi escape code for erasing the line and moving the cursor up
        this._clearString = '\r\x1B[K\r\x1B[1A'.repeat(statusString.split('\n').length + 1);
    }
    _printBriefSummary() {
        const counts = { numFailed: 0, numPassed: 0, numPending: 0 };
        const status = [];
        for (const [, checkMap] of this.checkFilesMap.entries()) {
            for (const [_, { result }] of checkMap.entries()) {
                if (!result) {
                    counts.numPending++;
                }
                else if (result.hasFailures) {
                    counts.numFailed++;
                }
                else {
                    counts.numPassed++;
                }
            }
        }
        status.push('');
        status.push([
            counts.numFailed ? chalk_1.default.bold.red(`${counts.numFailed} failed`) : undefined,
            counts.numPassed ? chalk_1.default.bold.green(`${counts.numPassed} passed`) : undefined,
            counts.numPending ? chalk_1.default.bold.magenta(`${counts.numPending} pending`) : undefined,
            `${this.numChecks} total`,
        ].filter(Boolean).join(', '));
        status.push('');
        const statusString = status.join('\n');
        (0, util_1.printLn)(statusString);
        // Ansi escape code for erasing the line and moving the cursor up
        this._clearString = '\r\x1B[K\r\x1B[1A'.repeat(statusString.split('\n').length + 1);
    }
    async _printTestSessionsUrl() {
        if (this.testSessionId) {
            try {
                const { data: { link } } = await api_1.testSessions.getShortLink(this.testSessionId);
                (0, util_1.printLn)(`${chalk_1.default.white('Detailed session summary at:')} ${chalk_1.default.underline.cyan(link)}`, 2);
            }
            catch {
                (0, util_1.printLn)(`${chalk_1.default.white('Detailed session summary at:')} ${chalk_1.default.underline.cyan((0, util_1.getTestSessionUrl)(this.testSessionId))}`, 2);
            }
        }
    }
    _runLocationString() {
        if (this.runLocation.type === 'PUBLIC') {
            return this.runLocation.region;
        }
        else {
            return `private location ${this.runLocation.slugName}`;
        }
    }
}
exports.default = AbstractListReporter;
//# sourceMappingURL=abstract-list.js.map