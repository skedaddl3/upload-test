"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@oclif/core");
const indent_string_1 = __importDefault(require("indent-string"));
const ci_info_1 = require("ci-info");
const api = __importStar(require("../rest/api"));
const config_1 = __importDefault(require("../services/config"));
const project_parser_1 = require("../services/project-parser");
const abstract_check_runner_1 = require("../services/abstract-check-runner");
const test_runner_1 = __importDefault(require("../services/test-runner"));
const checkly_config_loader_1 = require("../services/checkly-config-loader");
const test_filters_1 = require("../services/test-filters");
const authCommand_1 = require("./authCommand");
const constructs_1 = require("../constructs");
const util_1 = require("../services/util");
const reporter_1 = require("../reporters/reporter");
const common_messages_1 = __importDefault(require("../messages/common-messages"));
const util_2 = require("../reporters/util");
const snapshot_service_1 = require("../services/snapshot-service");
const DEFAULT_REGION = 'eu-central-1';
class Test extends authCommand_1.AuthCommand {
    async run() {
        var _a, _b, _c, _d, _e, _f, _g;
        core_1.ux.action.start('Parsing your project', undefined, { stdout: true });
        const { flags, argv } = await this.parse(Test);
        const { location: runLocation, 'private-location': privateRunLocation, grep, tags: targetTags, env, 'env-file': envFile, list, timeout, verbose: verboseFlag, reporter: reporterFlag, config: configFilename, record: shouldRecord, 'test-session-name': testSessionName, 'update-snapshots': updateSnapshots, } = flags;
        const filePatterns = argv;
        const testEnvVars = await (0, util_1.getEnvs)(envFile, env);
        const { configDirectory, configFilenames } = (0, util_1.splitConfigFilePath)(configFilename);
        const { config: checklyConfig, constructs: checklyConfigConstructs, } = await (0, checkly_config_loader_1.loadChecklyConfig)(configDirectory, configFilenames);
        const location = await this.prepareRunLocation(checklyConfig.cli, {
            runLocation: runLocation,
            privateRunLocation,
        });
        const verbose = this.prepareVerboseFlag(verboseFlag, (_a = checklyConfig.cli) === null || _a === void 0 ? void 0 : _a.verbose);
        const reporterTypes = this.prepareReportersTypes(reporterFlag, (_b = checklyConfig.cli) === null || _b === void 0 ? void 0 : _b.reporters);
        const { data: availableRuntimes } = await api.runtimes.getAll();
        const project = await (0, project_parser_1.parseProject)({
            directory: configDirectory,
            projectLogicalId: checklyConfig.logicalId,
            projectName: testSessionName !== null && testSessionName !== void 0 ? testSessionName : checklyConfig.projectName,
            repoUrl: checklyConfig.repoUrl,
            checkMatch: (_c = checklyConfig.checks) === null || _c === void 0 ? void 0 : _c.checkMatch,
            browserCheckMatch: (_e = (_d = checklyConfig.checks) === null || _d === void 0 ? void 0 : _d.browserChecks) === null || _e === void 0 ? void 0 : _e.testMatch,
            ignoreDirectoriesMatch: (_f = checklyConfig.checks) === null || _f === void 0 ? void 0 : _f.ignoreDirectoriesMatch,
            checkDefaults: checklyConfig.checks,
            browserCheckDefaults: (_g = checklyConfig.checks) === null || _g === void 0 ? void 0 : _g.browserChecks,
            availableRuntimes: availableRuntimes.reduce((acc, runtime) => {
                acc[runtime.name] = runtime;
                return acc;
            }, {}),
            checklyConfigConstructs,
        });
        const checks = Object.entries(project.data.check)
            .filter(([, check]) => {
            return !(check instanceof constructs_1.HeartbeatCheck);
        })
            .filter(([, check]) => {
            if (check instanceof constructs_1.BrowserCheck) {
                return (0, test_filters_1.filterByFileNamePattern)(filePatterns, check.scriptPath) ||
                    (0, test_filters_1.filterByFileNamePattern)(filePatterns, check.__checkFilePath);
            }
            else {
                return (0, test_filters_1.filterByFileNamePattern)(filePatterns, check.__checkFilePath);
            }
        })
            .filter(([, check]) => {
            return (0, test_filters_1.filterByCheckNamePattern)(grep, check.name);
        })
            .filter(([, check]) => {
            var _a;
            return (0, test_filters_1.filterByTags)((_a = targetTags === null || targetTags === void 0 ? void 0 : targetTags.map((tags) => tags.split(','))) !== null && _a !== void 0 ? _a : [], check.tags);
        })
            .map(([key, check]) => {
            var _a;
            check.logicalId = key;
            if (Object.keys(testEnvVars).length) {
                check.environmentVariables = ((_a = check.environmentVariables) === null || _a === void 0 ? void 0 : _a.filter((envVar) => !testEnvVars[envVar.key])) || [];
                for (const [key, value] of Object.entries(testEnvVars)) {
                    check.environmentVariables.push({
                        key,
                        value,
                        locked: true,
                    });
                }
            }
            return check;
        });
        for (const check of checks) {
            if (!(check instanceof constructs_1.BrowserCheck)) {
                continue;
            }
            check.snapshots = await (0, snapshot_service_1.uploadSnapshots)(check.rawSnapshots);
        }
        core_1.ux.action.stop();
        if (!checks.length) {
            this.log(`Unable to find checks to run${filePatterns[0] !== '.*' ? ' using [FILEARGS]=\'' + filePatterns + '\'' : ''}.`);
            return;
        }
        if (list) {
            this.listChecks(checks);
            return;
        }
        const reporters = (0, reporter_1.createReporters)(reporterTypes, location, verbose);
        const repoInfo = (0, util_1.getGitInformation)(project.repoUrl);
        const ciInfo = (0, util_1.getCiInformation)();
        const runner = new test_runner_1.default(config_1.default.getAccountId(), project, checks, location, timeout, verbose, shouldRecord, repoInfo, ciInfo.environment, updateSnapshots, configDirectory);
        runner.on(abstract_check_runner_1.Events.RUN_STARTED, (checks, testSessionId) => reporters.forEach(r => r.onBegin(checks, testSessionId)));
        runner.on(abstract_check_runner_1.Events.CHECK_INPROGRESS, (check, checkRunId) => {
            reporters.forEach(r => r.onCheckInProgress(check, checkRunId));
        });
        runner.on(abstract_check_runner_1.Events.MAX_SCHEDULING_DELAY_EXCEEDED, () => {
            reporters.forEach(r => r.onSchedulingDelayExceeded());
        });
        runner.on(abstract_check_runner_1.Events.CHECK_SUCCESSFUL, (checkRunId, check, result, links) => {
            if (result.hasFailures) {
                process.exitCode = 1;
            }
            reporters.forEach(r => r.onCheckEnd(checkRunId, {
                logicalId: check.logicalId,
                sourceFile: check.getSourceFile(),
                ...result,
            }, links));
        });
        runner.on(abstract_check_runner_1.Events.CHECK_FAILED, (checkRunId, check, message) => {
            reporters.forEach(r => r.onCheckEnd(checkRunId, {
                ...check,
                logicalId: check.logicalId,
                sourceFile: check.getSourceFile(),
                hasFailures: true,
                runError: message,
            }));
            process.exitCode = 1;
        });
        runner.on(abstract_check_runner_1.Events.RUN_FINISHED, () => reporters.forEach(r => r.onEnd()));
        runner.on(abstract_check_runner_1.Events.ERROR, (err) => {
            reporters.forEach(r => r.onError(err));
            process.exitCode = 1;
        });
        await runner.run();
    }
    prepareVerboseFlag(verboseFlag, cliVerboseFlag) {
        var _a;
        return (_a = verboseFlag !== null && verboseFlag !== void 0 ? verboseFlag : cliVerboseFlag) !== null && _a !== void 0 ? _a : false;
    }
    prepareReportersTypes(reporterFlag, cliReporters = []) {
        if (!reporterFlag && !cliReporters.length) {
            return [ci_info_1.isCI ? 'ci' : 'list'];
        }
        return reporterFlag ? [reporterFlag] : cliReporters;
    }
    async prepareRunLocation(configOptions = {}, cliFlags = {}) {
        // Command line options take precedence
        if (cliFlags.runLocation) {
            const { data: availableLocations } = await api.locations.getAll();
            if (availableLocations.some(l => l.region === cliFlags.runLocation)) {
                return { type: 'PUBLIC', region: cliFlags.runLocation };
            }
            throw new Error(`Unable to run checks on unsupported location "${cliFlags.runLocation}". ` +
                `Supported locations are:\n${availableLocations.map(l => `${l.region}`).join('\n')}`);
        }
        else if (cliFlags.privateRunLocation) {
            return this.preparePrivateRunLocation(cliFlags.privateRunLocation);
        }
        else if (configOptions.runLocation && configOptions.privateRunLocation) {
            throw new Error('Both runLocation and privateRunLocation fields were set in your Checkly config file.' +
                ` Please only specify one run location. The configured locations were' +
        ' "${configOptions.runLocation}" and "${configOptions.privateRunLocation}"`);
        }
        else if (configOptions.runLocation) {
            return { type: 'PUBLIC', region: configOptions.runLocation };
        }
        else if (configOptions.privateRunLocation) {
            return this.preparePrivateRunLocation(configOptions.privateRunLocation);
        }
        else {
            return { type: 'PUBLIC', region: DEFAULT_REGION };
        }
    }
    async preparePrivateRunLocation(privateLocationSlugName) {
        try {
            const privateLocations = await constructs_1.Session.getPrivateLocations();
            const privateLocation = privateLocations.find(({ slugName }) => slugName === privateLocationSlugName);
            if (privateLocation) {
                return { type: 'PRIVATE', id: privateLocation.id, slugName: privateLocationSlugName };
            }
            const { data: account } = await api.accounts.get(config_1.default.getAccountId());
            throw new Error(`The specified private location "${privateLocationSlugName}" was not found on account "${account.name}".`);
        }
        catch (err) {
            throw new Error(`Failed to get private locations. ${err.message}.`);
        }
    }
    listChecks(checks) {
        // Sort and print the checks in a way that's consistent with AbstractListReporter
        const sortedCheckFiles = [...new Set(checks.map((check) => check.getSourceFile()))].sort();
        const sortedChecks = checks.sort((a, b) => a.name.localeCompare(b.name));
        const checkFilesMap = new Map(sortedCheckFiles.map((file) => [file, []]));
        sortedChecks.forEach(check => {
            checkFilesMap.get(check.getSourceFile()).push(check);
        });
        (0, util_2.printLn)('Listing all checks:', 2, 1);
        for (const [sourceFile, checks] of checkFilesMap) {
            (0, util_2.printLn)(sourceFile);
            for (const check of checks) {
                (0, util_2.printLn)((0, indent_string_1.default)((0, util_2.formatCheckTitle)(util_2.CheckStatus.RUNNING, check), 2));
            }
        }
    }
}
exports.default = Test;
Test.coreCommand = true;
Test.hidden = false;
Test.description = 'Test your checks on Checkly.';
Test.flags = {
    location: core_1.Flags.string({
        char: 'l',
        description: 'The location to run the checks at.',
    }),
    'private-location': core_1.Flags.string({
        description: 'The private location to run checks at.',
        exclusive: ['location'],
    }),
    grep: core_1.Flags.string({
        char: 'g',
        description: 'Only run checks where the check name matches a regular expression.',
        default: '.*',
    }),
    tags: core_1.Flags.string({
        char: 't',
        description: 'Filter the checks to be run using a comma separated list of tags.' +
            ' Checks will only be run if they contain all of the specified tags.' +
            ' Multiple --tags flags can be passed, in which case checks will be run if they match any of the --tags filters.' +
            ' F.ex. `--tags production,webapp --tags production,backend` will run checks with tags (production AND webapp) OR (production AND backend).',
        multiple: true,
        required: false,
    }),
    env: core_1.Flags.string({
        char: 'e',
        description: 'Env vars to be passed to the test run.',
        exclusive: ['env-file'],
        multiple: true,
        default: [],
    }),
    'env-file': core_1.Flags.string({
        description: 'dotenv file path to be passed. For example --env-file="./.env"',
        exclusive: ['env'],
    }),
    list: core_1.Flags.boolean({
        default: false,
        description: 'list all checks but don\'t run them.',
    }),
    timeout: core_1.Flags.integer({
        default: abstract_check_runner_1.DEFAULT_CHECK_RUN_TIMEOUT_SECONDS,
        description: 'A timeout (in seconds) to wait for checks to complete.',
    }),
    verbose: core_1.Flags.boolean({
        char: 'v',
        description: 'Always show the full logs of the checks.',
        allowNo: true,
    }),
    reporter: core_1.Flags.string({
        char: 'r',
        description: 'A list of custom reporters for the test output.',
        options: ['list', 'dot', 'ci', 'github'],
    }),
    config: core_1.Flags.string({
        char: 'c',
        description: common_messages_1.default.configFile,
    }),
    record: core_1.Flags.boolean({
        description: 'Record test results in Checkly as a test session with full logs, traces and videos.',
        default: false,
    }),
    'test-session-name': core_1.Flags.string({
        char: 'n',
        description: 'A name to use when storing results in Checkly with --record.',
    }),
    'update-snapshots': core_1.Flags.boolean({
        char: 'u',
        description: 'Update any snapshots using the actual result of this test run.',
        default: false,
    }),
};
Test.args = {
    fileArgs: core_1.Args.string({
        name: 'files',
        required: false,
        description: 'Only run checks where the file name matches a regular expression',
        default: '.*',
    }),
};
Test.strict = false;
//# sourceMappingURL=test.js.map