"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@oclif/core");
const ci_info_1 = require("ci-info");
const api = __importStar(require("../rest/api"));
const authCommand_1 = require("./authCommand");
const checkly_config_loader_1 = require("../services/checkly-config-loader");
const util_1 = require("../services/util");
const trigger_runner_1 = __importStar(require("../services/trigger-runner"));
const abstract_check_runner_1 = require("../services/abstract-check-runner");
const config_1 = __importDefault(require("../services/config"));
const reporter_1 = require("../reporters/reporter");
const constructs_1 = require("../constructs");
const DEFAULT_REGION = 'eu-central-1';
class Trigger extends authCommand_1.AuthCommand {
    async run() {
        var _a, _b, _c;
        const { flags } = await this.parse(Trigger);
        const { location: runLocation, 'private-location': privateRunLocation, config: configFilename, tags: targetTags, timeout, verbose: verboseFlag, record: shouldRecord, reporter: reporterFlag, env, 'env-file': envFile, 'test-session-name': testSessionName, } = flags;
        const envVars = await (0, util_1.getEnvs)(envFile, env);
        const { configDirectory, configFilenames } = (0, util_1.splitConfigFilePath)(configFilename);
        let checklyConfig;
        try {
            const { config } = await (0, checkly_config_loader_1.loadChecklyConfig)(configDirectory, configFilenames);
            checklyConfig = config;
        }
        catch (err) { } // Don't throw an error if the config file is missing
        const location = await this.prepareRunLocation(checklyConfig === null || checklyConfig === void 0 ? void 0 : checklyConfig.cli, {
            runLocation: runLocation,
            privateRunLocation,
        });
        const verbose = this.prepareVerboseFlag(verboseFlag, (_a = checklyConfig === null || checklyConfig === void 0 ? void 0 : checklyConfig.cli) === null || _a === void 0 ? void 0 : _a.verbose);
        const reporterTypes = this.prepareReportersTypes(reporterFlag, (_b = checklyConfig === null || checklyConfig === void 0 ? void 0 : checklyConfig.cli) === null || _b === void 0 ? void 0 : _b.reporters);
        const reporters = (0, reporter_1.createReporters)(reporterTypes, location, verbose);
        const repoInfo = (0, util_1.getGitInformation)();
        const ciInfo = (0, util_1.getCiInformation)();
        const runner = new trigger_runner_1.default(config_1.default.getAccountId(), timeout, verbose, shouldRecord, location, (_c = targetTags === null || targetTags === void 0 ? void 0 : targetTags.map((tags) => tags.split(','))) !== null && _c !== void 0 ? _c : [], Object.entries(envVars).map(([key, value]) => ({ key, value })), repoInfo, ciInfo.environment, testSessionName);
        // TODO: This is essentially the same for `checkly test`. Maybe reuse code.
        runner.on(abstract_check_runner_1.Events.RUN_STARTED, (checks, testSessionId) => reporters.forEach(r => r.onBegin(checks, testSessionId)));
        runner.on(abstract_check_runner_1.Events.CHECK_SUCCESSFUL, (checkRunId, _, result, links) => {
            if (result.hasFailures) {
                process.exitCode = 1;
            }
            reporters.forEach(r => r.onCheckEnd(checkRunId, result, links));
        });
        runner.on(abstract_check_runner_1.Events.CHECK_FAILED, (checkRunId, check, message) => {
            reporters.forEach(r => r.onCheckEnd(checkRunId, {
                ...check,
                hasFailures: true,
                runError: message,
            }));
            process.exitCode = 1;
        });
        runner.on(abstract_check_runner_1.Events.RUN_FINISHED, () => reporters.forEach(r => r.onEnd()));
        runner.on(abstract_check_runner_1.Events.ERROR, (err) => {
            if (err instanceof trigger_runner_1.NoMatchingChecksError) {
                // For consistency with `checkly test`, we log a message and exit with code 0.
                this.log('No matching checks were found.');
                return;
            }
            reporters.forEach(r => r.onError(err));
            process.exitCode = 1;
        });
        await runner.run();
    }
    // TODO: Reuse prepare* methods from the `checkly test command`
    async prepareRunLocation(configOptions = {}, cliFlags = {}) {
        // Command line options take precedence
        if (cliFlags.runLocation) {
            const { data: availableLocations } = await api.locations.getAll();
            if (availableLocations.some(l => l.region === cliFlags.runLocation)) {
                return { type: 'PUBLIC', region: cliFlags.runLocation };
            }
            throw new Error(`Unable to run checks on unsupported location "${cliFlags.runLocation}". ` +
                `Supported locations are:\n${availableLocations.map(l => `${l.region}`).join('\n')}`);
        }
        else if (cliFlags.privateRunLocation) {
            return this.preparePrivateRunLocation(cliFlags.privateRunLocation);
        }
        else if (configOptions.runLocation && configOptions.privateRunLocation) {
            throw new Error('Both runLocation and privateRunLocation fields were set in the Checkly config file.' +
                ` Please only specify one run location. The configured locations were' +
        ' "${configOptions.runLocation}" and "${configOptions.privateRunLocation}"`);
        }
        else if (configOptions.runLocation) {
            return { type: 'PUBLIC', region: configOptions.runLocation };
        }
        else if (configOptions.privateRunLocation) {
            return this.preparePrivateRunLocation(configOptions.privateRunLocation);
        }
        else {
            return { type: 'PUBLIC', region: DEFAULT_REGION };
        }
    }
    async preparePrivateRunLocation(privateLocationSlugName) {
        try {
            const privateLocations = await constructs_1.Session.getPrivateLocations();
            const privateLocation = privateLocations.find(({ slugName }) => slugName === privateLocationSlugName);
            if (privateLocation) {
                return { type: 'PRIVATE', id: privateLocation.id, slugName: privateLocationSlugName };
            }
            const { data: account } = await api.accounts.get(config_1.default.getAccountId());
            throw new Error(`The specified private location "${privateLocationSlugName}" was not found on account "${account.name}".`);
        }
        catch (err) {
            throw new Error(`Failed to get private locations. ${err.message}.`);
        }
    }
    prepareVerboseFlag(verboseFlag, cliVerboseFlag) {
        var _a;
        return (_a = verboseFlag !== null && verboseFlag !== void 0 ? verboseFlag : cliVerboseFlag) !== null && _a !== void 0 ? _a : false;
    }
    prepareReportersTypes(reporterFlag, cliReporters = []) {
        if (!reporterFlag && !cliReporters.length) {
            return [ci_info_1.isCI ? 'ci' : 'list'];
        }
        return reporterFlag ? [reporterFlag] : cliReporters;
    }
}
exports.default = Trigger;
Trigger.coreCommand = true;
Trigger.hidden = false;
Trigger.description = 'Trigger your checks on Checkly.';
Trigger.flags = {
    location: core_1.Flags.string({
        char: 'l',
        description: 'The location to run the checks at.',
    }),
    'private-location': core_1.Flags.string({
        description: 'The private location to run checks at.',
        exclusive: ['location'],
    }),
    tags: core_1.Flags.string({
        char: 't',
        description: 'Filter the checks to be run using a comma separated list of tags.' +
            ' Checks will only be run if they contain all of the specified tags.' +
            ' Multiple --tags flags can be passed, in which case checks will be run if they match any of the --tags filters.' +
            ' F.ex. `--tags production,webapp --tags production,backend` will run checks with tags (production AND webapp) OR (production AND backend).',
        multiple: true,
        required: false,
    }),
    config: core_1.Flags.string({
        char: 'c',
        description: 'The Checkly CLI config filename.',
    }),
    timeout: core_1.Flags.integer({
        default: 240,
        description: 'A timeout (in seconds) to wait for checks to complete.',
    }),
    verbose: core_1.Flags.boolean({
        char: 'v',
        description: 'Always show the full logs of the checks.',
        allowNo: true,
    }),
    reporter: core_1.Flags.string({
        char: 'r',
        description: 'A list of custom reporters for the test output.',
        options: ['list', 'dot', 'ci', 'github'],
    }),
    env: core_1.Flags.string({
        char: 'e',
        description: 'Env vars to be passed to the check run.',
        exclusive: ['env-file'],
        multiple: true,
        default: [],
    }),
    'env-file': core_1.Flags.string({
        description: 'dotenv file path to be passed. For example --env-file="./.env"',
        exclusive: ['env'],
    }),
    record: core_1.Flags.boolean({
        description: 'Record check results in Checkly as a test session with full logs, traces and videos.',
        default: false,
    }),
    'test-session-name': core_1.Flags.string({
        char: 'n',
        description: 'A name to use when storing results in Checkly with --record.',
    }),
};
//# sourceMappingURL=trigger.js.map