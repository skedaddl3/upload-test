"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_CHECK_RUN_TIMEOUT_SECONDS = exports.Events = void 0;
const api_1 = require("../rest/api");
const socket_client_1 = require("./socket-client");
const p_queue_1 = __importDefault(require("p-queue"));
const uuid = __importStar(require("uuid"));
const node_events_1 = require("node:events");
// eslint-disable-next-line no-restricted-syntax
var Events;
(function (Events) {
    Events["CHECK_REGISTERED"] = "CHECK_REGISTERED";
    Events["CHECK_INPROGRESS"] = "CHECK_INPROGRESS";
    Events["CHECK_FAILED"] = "CHECK_FAILED";
    Events["CHECK_SUCCESSFUL"] = "CHECK_SUCCESSFUL";
    Events["CHECK_FINISHED"] = "CHECK_FINISHED";
    Events["RUN_STARTED"] = "RUN_STARTED";
    Events["RUN_FINISHED"] = "RUN_FINISHED";
    Events["ERROR"] = "ERROR";
    Events["MAX_SCHEDULING_DELAY_EXCEEDED"] = "MAX_SCHEDULING_DELAY_EXCEEDED";
})(Events = exports.Events || (exports.Events = {}));
exports.DEFAULT_CHECK_RUN_TIMEOUT_SECONDS = 300;
const DEFAULT_SCHEDULING_DELAY_EXCEEDED_MS = 20000;
class AbstractCheckRunner extends node_events_1.EventEmitter {
    constructor(accountId, timeout, verbose) {
        super();
        this.checks = new Map();
        this.timeouts = new Map();
        this.queue = new p_queue_1.default({ autoStart: false, concurrency: 1 });
        this.timeout = timeout;
        this.verbose = verbose;
        this.accountId = accountId;
    }
    async run() {
        let socketClient = null;
        try {
            socketClient = await socket_client_1.SocketClient.connect();
            const checkRunSuiteId = uuid.v4();
            // Configure the socket listener and allChecksFinished listener before starting checks to avoid race conditions
            await this.configureResultListener(checkRunSuiteId, socketClient);
            const { testSessionId, checks } = await this.scheduleChecks(checkRunSuiteId);
            this.testSessionId = testSessionId;
            this.checks = new Map(checks.map(({ check, checkRunId, testResultId }) => [checkRunId, { check, testResultId }]));
            // `processMessage()` assumes that `this.timeouts` always has an entry for non-timed-out checks.
            // To ensure that this is the case, we call `setAllTimeouts()` before `queue.start()`.
            // Otherwise, we risk a race condition where check results are received before the timeout is set.
            // This would cause `processMessage()` to mistakenly skip check results and consider the checks timed-out.
            this.setAllTimeouts();
            // Add timeout to fire an event after DEFAULT_SCHEDULING_DELAY_EXCEEDED_MS to let reporters know it's time
            // to display a hint messages if some checks are still being scheduled.
            this.startSchedulingDelayTimeout();
            // `allChecksFinished` should be started before processing check results in `queue.start()`.
            // Otherwise, there could be a race condition causing check results to be missed by `allChecksFinished()`.
            const allChecksFinished = this.allChecksFinished();
            /// / Need to structure the checks depending on how it went
            this.emit(Events.RUN_STARTED, checks, testSessionId);
            // Start the queue after the test session run rest call is completed to avoid race conditions
            this.queue.start();
            await allChecksFinished;
            this.emit(Events.RUN_FINISHED, testSessionId);
        }
        catch (err) {
            this.disableAllTimeouts();
            this.emit(Events.ERROR, err);
        }
        finally {
            if (socketClient) {
                await socketClient.end();
            }
        }
    }
    async configureResultListener(checkRunSuiteId, socketClient) {
        socketClient.on('message', (topic, rawMessage) => {
            const message = JSON.parse(rawMessage.toString('utf8'));
            const topicComponents = topic.split('/');
            const checkRunId = topicComponents[4];
            const subtopic = topicComponents[5];
            this.queue.add(() => this.processMessage(checkRunId, subtopic, message));
        });
        await socketClient.subscribe(`account/${this.accountId}/ad-hoc-check-results/${checkRunSuiteId}/+/+`);
    }
    async processMessage(checkRunId, subtopic, message) {
        if (!this.timeouts.has(checkRunId)) {
            // The check has already timed out. We return early to avoid reporting a duplicate result.
            return;
        }
        if (!this.checks.get(checkRunId)) {
            // The check has no checkRunId associated.
            return;
        }
        const { check, testResultId } = this.checks.get(checkRunId);
        if (subtopic === 'run-start') {
            this.emit(Events.CHECK_INPROGRESS, check, checkRunId);
        }
        else if (subtopic === 'run-end') {
            this.disableTimeout(checkRunId);
            const { result } = message;
            await this.processCheckResult(result);
            const links = testResultId && result.hasFailures && await this.getShortLinks(testResultId);
            this.emit(Events.CHECK_SUCCESSFUL, checkRunId, check, result, links);
            this.emit(Events.CHECK_FINISHED, check);
        }
        else if (subtopic === 'error') {
            this.disableTimeout(checkRunId);
            this.emit(Events.CHECK_FAILED, checkRunId, check, message);
            this.emit(Events.CHECK_FINISHED, check);
        }
    }
    async processCheckResult(result) {
        const { region, logPath, checkRunDataPath, } = result.assets;
        if (logPath && (this.verbose || result.hasFailures)) {
            result.logs = await api_1.assets.getLogs(region, logPath);
        }
        if (checkRunDataPath && (this.verbose || result.hasFailures)) {
            result.checkRunData = await api_1.assets.getCheckRunData(region, checkRunDataPath);
        }
    }
    allChecksFinished() {
        let finishedCheckCount = 0;
        const numChecks = this.checks.size;
        if (numChecks === 0) {
            return Promise.resolve();
        }
        return new Promise((resolve) => {
            this.on(Events.CHECK_FINISHED, () => {
                finishedCheckCount++;
                if (finishedCheckCount === numChecks)
                    resolve();
            });
        });
    }
    setAllTimeouts() {
        Array.from(this.checks.entries()).forEach(([checkRunId, { check }]) => this.timeouts.set(checkRunId, setTimeout(() => {
            this.timeouts.delete(checkRunId);
            let errorMessage = `Reached timeout of ${this.timeout} seconds waiting for check result.`;
            // Checkly should always report a result within 240s.
            // If the default timeout was used, we should point the user to the status page and support email.
            if (this.timeout === exports.DEFAULT_CHECK_RUN_TIMEOUT_SECONDS) {
                errorMessage += ' Checkly may be experiencing problems. Please check https://is.checkly.online or reach out to support@checklyhq.com.';
            }
            this.emit(Events.CHECK_FAILED, checkRunId, check, errorMessage);
            this.emit(Events.CHECK_FINISHED, check);
        }, this.timeout * 1000)));
    }
    disableAllTimeouts() {
        if (!this.checks) {
            return;
        }
        Array.from(this.checks.entries()).forEach(([checkRunId]) => this.disableTimeout(checkRunId));
        if (this.schedulingDelayExceededTimeout) {
            clearTimeout(this.schedulingDelayExceededTimeout);
            this.schedulingDelayExceededTimeout = undefined;
        }
    }
    startSchedulingDelayTimeout() {
        let scheduledCheckCount = 0;
        const numChecks = this.checks.size;
        if (numChecks === 0) {
            return;
        }
        this.schedulingDelayExceededTimeout = setTimeout(() => {
            this.emit(Events.MAX_SCHEDULING_DELAY_EXCEEDED);
            this.schedulingDelayExceededTimeout = undefined;
        }, DEFAULT_SCHEDULING_DELAY_EXCEEDED_MS);
        this.on(Events.CHECK_INPROGRESS, () => {
            scheduledCheckCount++;
            if (scheduledCheckCount === numChecks)
                clearTimeout(this.schedulingDelayExceededTimeout);
        });
    }
    disableTimeout(timeoutKey) {
        const timeout = this.timeouts.get(timeoutKey);
        clearTimeout(timeout);
        this.timeouts.delete(timeoutKey);
    }
    async getShortLinks(testResultId) {
        try {
            if (!this.testSessionId) {
                return;
            }
            const { data: links } = await api_1.testSessions.getResultShortLinks(this.testSessionId, testResultId);
            return links;
        }
        catch {
        }
    }
}
exports.default = AbstractCheckRunner;
//# sourceMappingURL=abstract-check-runner.js.map