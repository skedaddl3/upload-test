"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parser = void 0;
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const acorn = __importStar(require("acorn"));
const walk = __importStar(require("acorn-walk"));
const collector_1 = require("./collector");
const errors_1 = require("./errors");
// Our custom configuration to handle walking errors
// eslint-disable-next-line @typescript-eslint/no-empty-function
const ignore = (_node, _st, _c) => { };
const PACKAGE_EXTENSION = `${path.sep}package.json`;
const JS_RESOLVE_ORDER = [
    '.js',
    '.mjs',
    PACKAGE_EXTENSION,
    `${path.sep}index.js`,
    // TODO: Check the module type in package.json to figure out the esm and common js file extensions
    `${path.sep}index.mjs`,
];
const TS_RESOLVE_ORDER = [
    '.ts',
    '.js',
    '.mjs',
    PACKAGE_EXTENSION,
    `${path.sep}index.ts`,
    `${path.sep}index.js`,
    // TODO: Check the module type in package.json to figure out the esm and common js file extensions
    `${path.sep}index.mjs`,
];
const supportedBuiltinModules = [
    'assert', 'buffer', 'crypto', 'dns', 'fs', 'path', 'querystring', 'readline ', 'stream', 'string_decoder',
    'timers', 'tls', 'url', 'util', 'zlib',
];
function validateEntrypoint(entrypoint) {
    const extension = path.extname(entrypoint);
    if (extension !== '.js' && extension !== '.ts' && extension !== '.mjs') {
        throw new Error(`Unsupported file extension for ${entrypoint}`);
    }
    try {
        const content = fs.readFileSync(entrypoint, { encoding: 'utf-8' });
        return { extension, content };
    }
    catch (err) {
        throw new errors_1.DependencyParseError(entrypoint, [entrypoint], [], []);
    }
}
let tsParser;
function getTsParser() {
    if (tsParser) {
        return tsParser;
    }
    try {
        tsParser = require('@typescript-eslint/typescript-estree');
        const AST_NODE_TYPES = tsParser.AST_NODE_TYPES;
        // Our custom configuration to handle walking errors
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        Object.values(AST_NODE_TYPES).forEach((astType) => {
            var _a;
            // Only handle the TS specific ones
            if (!astType.startsWith('TS')) {
                return;
            }
            walk.base[astType] = (_a = walk.base[astType]) !== null && _a !== void 0 ? _a : ignore;
        });
        return tsParser;
    }
    catch (err) {
        if (err.code === 'ERR_MODULE_NOT_FOUND' || err.code === 'MODULE_NOT_FOUND') {
            throw new Error('Please install "typescript" to use TypeScript-code in check files');
        }
        throw err;
    }
}
class Parser {
    // TODO: pass a npm matrix of supported npm modules
    // Maybe pass a cache so we don't have to fetch files separately all the time
    constructor(supportedNpmModules) {
        this.supportedModules = new Set([...supportedBuiltinModules, ...supportedNpmModules]);
    }
    parse(entrypoint) {
        const { extension, content } = validateEntrypoint(entrypoint);
        /*
      * The importing of files forms a directed graph.
      * Vertices are source files and edges are from importing other files.
      * We can find all of the files we need to run the check by traversing this graph.
      * In this implementation, we use breadth first search.
      */
        const collector = new collector_1.Collector(entrypoint, content);
        const bfsQueue = [{ filePath: entrypoint, content }];
        while (bfsQueue.length > 0) {
            // Since we just checked the length, shift() will never return undefined.
            // We can add a not-null assertion operator (!).
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const item = bfsQueue.shift();
            if (item.filePath.endsWith(PACKAGE_EXTENSION)) {
                // Holds info about the main file and doesn't need to be parsed
                continue;
            }
            const { module, error } = Parser.parseDependencies(item.filePath, item.content);
            if (error) {
                collector.addParsingError(item.filePath, error.message);
                continue;
            }
            const unsupportedDependencies = module.npmDependencies.filter((dep) => !this.supportedModules.has(dep));
            if (unsupportedDependencies.length) {
                collector.addUnsupportedNpmDependencies(item.filePath, unsupportedDependencies);
            }
            const localDependenciesResolvedPaths = [];
            module.localDependencies.forEach((localDependency) => {
                const filePath = path.join(path.dirname(item.filePath), localDependency);
                try {
                    const deps = Parser.readDependency(filePath, extension);
                    localDependenciesResolvedPaths.push(...deps);
                }
                catch (err) {
                    collector.addMissingFile(filePath);
                }
            });
            localDependenciesResolvedPaths.forEach(({ filePath, content }) => {
                if (collector.hasDependency(filePath)) {
                    return;
                }
                collector.addDependency(filePath, content);
                bfsQueue.push({ filePath, content });
            });
        }
        collector.validate();
        return collector.getItems();
    }
    static readDependency(filePath, preferedExtenstion) {
        // Read the specific file if it has an extension
        if (preferedExtenstion === '.js') {
            return Parser.tryReadFileExt(filePath, JS_RESOLVE_ORDER);
        }
        else {
            return Parser.tryReadFileExt(filePath, TS_RESOLVE_ORDER);
        }
    }
    static tryReadFileExt(filePath, exts) {
        for (const extension of ['', ...exts]) {
            try {
                const deps = [];
                const fullPath = filePath + extension;
                const content = fs.readFileSync(fullPath, { encoding: 'utf-8' });
                deps.push({ filePath: fullPath, content });
                if (extension === PACKAGE_EXTENSION) {
                    const { main } = JSON.parse(content);
                    // TODO: Check the module type to figure out the esm and common js file extensions
                    // It might be different than js and mjs
                    if (!main || !main.length) {
                        // No main is defined. This means package.json doesn't have a specific entry
                        continue;
                    }
                    const mainFile = path.join(filePath, main);
                    deps.push({
                        filePath: mainFile, content: fs.readFileSync(mainFile, { encoding: 'utf-8' }),
                    });
                }
                return deps;
            }
            catch (err) { }
        }
        throw new Error(`Cannot find file ${filePath}`);
    }
    static parseDependencies(filePath, contents) {
        const localDependencies = new Set();
        const npmDependencies = new Set();
        const extension = path.extname(filePath);
        try {
            if (extension === '.js' || extension === '.mjs') {
                const ast = acorn.parse(contents, {
                    allowReturnOutsideFunction: true,
                    ecmaVersion: 'latest',
                    allowImportExportEverywhere: true,
                    allowAwaitOutsideFunction: true,
                });
                walk.simple(ast, Parser.jsNodeVisitor(localDependencies, npmDependencies));
            }
            else if (extension === '.ts') {
                const tsParser = getTsParser();
                const ast = tsParser.parse(contents, {});
                // The AST from typescript-estree is slightly different from the type used by acorn-walk.
                // This doesn't actually cause problems (both are "ESTree's"), but we need to ignore type errors here.
                // @ts-ignore
                walk.simple(ast, Parser.tsNodeVisitor(tsParser, localDependencies, npmDependencies));
            }
            else {
                throw new Error(`Unsupported file extension for ${filePath}`);
            }
        }
        catch (err) {
            return {
                module: {
                    localDependencies: Array.from(localDependencies),
                    npmDependencies: Array.from(npmDependencies),
                },
                error: err,
            };
        }
        return {
            module: {
                localDependencies: Array.from(localDependencies),
                npmDependencies: Array.from(npmDependencies),
            },
        };
    }
    static jsNodeVisitor(localDependencies, npmDependencies) {
        return {
            CallExpression(node) {
                if (!Parser.isRequireExpression(node))
                    return;
                const requireStringArg = Parser.getRequireStringArg(node);
                Parser.registerDependency(requireStringArg, localDependencies, npmDependencies);
            },
            ImportDeclaration(node) {
                if (node.source.type !== 'Literal')
                    return;
                Parser.registerDependency(node.source.value, localDependencies, npmDependencies);
            },
            ExportNamedDeclaration(node) {
                if (node.source === null)
                    return;
                if (node.source.type !== 'Literal')
                    return;
                Parser.registerDependency(node.source.value, localDependencies, npmDependencies);
            },
        };
    }
    static tsNodeVisitor(tsParser, localDependencies, npmDependencies) {
        return {
            ImportDeclaration(node) {
                // For now, we only support literal strings in the import statement
                if (node.source.type !== tsParser.TSESTree.AST_NODE_TYPES.Literal)
                    return;
                Parser.registerDependency(node.source.value, localDependencies, npmDependencies);
            },
            ExportNamedDeclaration(node) {
                // The statement isn't importing another dependency
                if (node.source === null)
                    return;
                // For now, we only support literal strings in the import statement
                if (node.source.type !== tsParser.TSESTree.AST_NODE_TYPES.Literal)
                    return;
                Parser.registerDependency(node.source.value, localDependencies, npmDependencies);
            },
        };
    }
    static isRequireExpression(node) {
        if (node.type !== 'CallExpression') {
            // Ignore AST nodes that aren't call expressions
            return false;
        }
        else if (node.arguments.length === 0) {
            // Weird case of `require()` or `module.require()` without arguments
            return false;
        }
        else if (node.callee.type === 'Identifier') {
            // Handle the case of a simple call to `require('dependency')`
            return node.callee.name === 'require';
        }
        else if (node.callee.type === 'MemberExpression') {
            // Handle calls to `module.require('dependency')`
            const { object, property } = node.callee;
            return object.type === 'Identifier' &&
                object.name === 'module' &&
                property.type === 'Identifier' &&
                property.name === 'require';
        }
        else {
            return false;
        }
    }
    static getRequireStringArg(node) {
        if (node.arguments[0].type === 'Literal') {
            return node.arguments[0].value;
        }
        else if (node.arguments[0].type === 'TemplateLiteral') {
            return node.arguments[0].quasis[0].value.cooked;
        }
        else {
            /*
            * It might be that `require` is called with a variable - `require(myPackage)`.
            * Unfortunately supporting that case would be complicated.
            * We just skip the dependency and hope that the check still works.
            */
            return null;
        }
    }
    static registerDependency(importArg, localDependencies, npmDependencies) {
        // TODO: We currently don't support import path aliases, f.ex: `import { Something } from '@services/my-service'`
        if (!importArg) {
            // If there's no importArg, don't register a dependency
        }
        else if (importArg.startsWith('/') || importArg.startsWith('./') || importArg.startsWith('../')) {
            localDependencies.add(importArg);
        }
        else {
            npmDependencies.add(importArg);
        }
    }
}
exports.Parser = Parser;
//# sourceMappingURL=parser.js.map