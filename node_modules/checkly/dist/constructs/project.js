"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Session = exports.Project = void 0;
const api = __importStar(require("../rest/api"));
const construct_1 = require("./construct");
const validator_error_1 = require("./validator-error");
const _1 = require("./");
class Project extends construct_1.Construct {
    /**
     * Constructs the Project instance
     *
     * @param logicalId unique project identifier
     * @param props project configuration properties
     */
    constructor(logicalId, props) {
        super(Project.__checklyType, logicalId);
        this.data = {
            check: {},
            'check-group': {},
            'alert-channel': {},
            'alert-channel-subscription': {},
            'maintenance-window': {},
            'private-location': {},
            'private-location-check-assignment': {},
            'private-location-group-assignment': {},
            dashboard: {},
        };
        if (!props.name) {
            // TODO: Can we collect a list of validation errors and return them all at once? This might be better UX.
            throw new validator_error_1.ValidationError('Please give your project a name in the "name" property.');
        }
        this.name = props.name;
        this.repoUrl = props.repoUrl;
        this.logicalId = logicalId;
    }
    addResource(type, logicalId, resource) {
        if (this.data[type][logicalId]) {
            throw new Error(`Resource of type '${type}' with logical id '${logicalId}' already exists.`);
        }
        this.data[type][logicalId] = resource;
    }
    synthesize(addTestOnly = true) {
        const project = {
            logicalId: this.logicalId,
            name: this.name,
            repoUrl: this.repoUrl,
        };
        return {
            project,
            resources: [
                ...this.synthesizeRecord(this.data.check, addTestOnly),
                ...this.synthesizeRecord(this.data['check-group']),
                ...this.synthesizeRecord(this.data['alert-channel']),
                ...this.synthesizeRecord(this.data['alert-channel-subscription']),
                ...this.synthesizeRecord(this.data['maintenance-window']),
                ...this.synthesizeRecord(this.data['private-location']),
                ...this.synthesizeRecord(this.data['private-location-check-assignment']),
                ...this.synthesizeRecord(this.data['private-location-group-assignment']),
                ...this.synthesizeRecord(this.data.dashboard),
            ],
        };
    }
    getTestOnlyConstructs() {
        return Object
            .values(this.data)
            .flatMap((record) => Object
            .values(record)
            .filter((construct) => construct instanceof _1.Check && construct.testOnly));
    }
    getHeartbeatLogicalIds() {
        return Object
            .values(this.data.check)
            .filter((construct) => construct instanceof _1.HeartbeatCheck)
            .map((construct) => construct.logicalId);
    }
    synthesizeRecord(record, addTestOnly = true) {
        return Object.entries(record)
            .filter(([, construct]) => construct instanceof _1.Check ? !construct.testOnly || addTestOnly : true)
            .map(([key, construct]) => ({
            logicalId: key,
            type: construct.type,
            physicalId: construct.physicalId,
            member: construct.member,
            payload: construct.synthesize(),
        }));
    }
}
exports.Project = Project;
Project.__checklyType = 'project';
class Session {
    static registerConstruct(construct) {
        if (Session.project) {
            Session.project.addResource(construct.type, construct.logicalId, construct);
        }
        else if (Session.loadingChecklyConfigFile && construct.allowInChecklyConfig()) {
            Session.checklyConfigFileConstructs.push(construct);
        }
        else {
            throw new Error('Internal Error: Session is not properly configured for using a construct. Please contact Checkly support on support@checklyhq.com');
        }
    }
    static validateCreateConstruct(construct) {
        if (!/^[A-Za-z0-9_\-/#.]+$/.test(construct.logicalId)) {
            throw new validator_error_1.ValidationError(`The "logicalId" can only include the following characters: [A-Za-z0-9_-/#.]. (logicalId='${construct.logicalId}')`);
        }
        if (construct.type === Project.__checklyType) {
            // Creating the construct is allowed - We're creating the project.
        }
        else if (Session.project) {
            // Creating the construct is allowed - We're in the process of parsing the project.
        }
        else if (Session.loadingChecklyConfigFile && construct.allowInChecklyConfig()) {
            // Creating the construct is allowed - We're in the process of parsing the Checkly config.
        }
        else if (Session.loadingChecklyConfigFile) {
            throw new Error(`Creating a ${construct.constructor.name} construct in the Checkly config file isn't supported.`);
        }
        else {
            throw new Error(`Unable to create a construct '${construct.constructor.name}' outside a Checkly CLI project.`);
        }
    }
    static async getPrivateLocations() {
        if (!Session.privateLocations) {
            const { data: privateLocations } = await api.privateLocations.getAll();
            Session.privateLocations = privateLocations;
        }
        return Session.privateLocations;
    }
}
exports.Session = Session;
//# sourceMappingURL=project.js.map